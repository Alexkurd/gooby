#!/usr/bin/env python
# -*- coding: utf-8 -*-


"""
@author: tetra5 <tetra5dotorg@gmail.com>
"""


__version__ = "2012.2"


import re
import urllib
import urllib2
import time

try:
    from lxml import etree
except ImportError:
    try:
        from xml.etree import cElementTree as etree
    except ImportError:
        from xml.etree import ElementTree as etree

from plugin import ChatCommandPlugin


_cache = {}
# Cache time to live in seconds.
_cache_ttl = 1200


class APIError(Exception):
    pass


def retry(exception, tries=10, delay=3, backoff=1):
    """Retries a function or method until it stops generating specified
    exception.

    @param exception: Exception generated by decorated function or method.
    @param tries: Number of tries.
    @param delay: Delay between tries in seconds.
    @param backoff: Factor by which the delay should lengthen after each
    failure.
    """
    def wrapper(f):
        def f_retry(*args, **kwargs):
            mtries, mdelay = tries, delay
            while mtries > 0:
                try:
                    return f(*args, **kwargs)
                except exception:
                    time.sleep(mdelay)
                    mtries -= 1
                    mdelay *= backoff
            return
        return f_retry
    return wrapper


def fahrenheit_to_celsius(temp_f):
    """Fahrenheit to Celsius degrees conversion.

    @param temp_f: Temperature in Fahrenheit degrees.

    >>> fahrenheit_to_celsius("98.6")
    37
    >>> fahrenheit_to_celsius(98.6)
    37
    """
    if temp_f is None:
        return
    if not isinstance(temp_f, float):
        temp_f = float(temp_f)
    return int((temp_f - 32) * 5 / 9)


def celsius_to_fahrenheit(temp_c):
    """Celsius to Fahrenheit degrees conversion.

    @param temp_c: Temperature in Celsius degrees.

    >>> celsius_to_fahrenheit("37")
    98
    >>> celsius_to_fahrenheit(37)
    98
    """
    if temp_c is None:
        return
    if not isinstance(temp_c, float):
        temp_c = float(temp_c)
    return int(temp_c * 9 / 5 + 32)


def get_google_weather_forecast(location, language="en"):
    """Google Weather API client.

    @param location: ZIP code, city, city + country, latitude/longitude,
    probably some more. Whatever Google is able to handle.
    @param language: ISO 639-1 Language code.
    http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes

    Returns parsed data dictionary.

    Raises APIError exception when:
    a) it was impossible to retrieve API response;
    b) API has returned empty response (unknown/incorrect location).

    >>> data = get_google_weather_forecast(location="moscow", language="en")
    >>> city = data["forecast_information"]["city"]
    >>> city in ("Moscow, Moscow", "Moscow, Moskva")
    True
    """
    global _cache
    global _chache_ttl

    cached = _cache.get(location)
    if cached:
        cache_time, data = cached
        if time.time() - cache_time <= _cache_ttl:
            return data

    api_url = "http://www.google.com/ig/api?"

    location = location.encode("utf-8")
    url = api_url + urllib.urlencode({"weather": location, "hl": language})

    headers = {
        "User-Agent": "Googlebot/2.1 (+http://www.googlebot.com/bot.html)",
        }
    opener = urllib2.build_opener()
    opener.addheaders = [(k, v) for k, v in headers.iteritems()]

    @retry((urllib2.URLError, urllib2.HTTPError, etree.ParseError))
    def retrieve_and_process_response():
        response = opener.open(fullurl=url, timeout=2)
        element_tree = etree.ElementTree()
        return element_tree.parse(response)

    root = retrieve_and_process_response()
    if root is None:
        raise APIError("Unable to retrieve weather forecast.")

    """
    Typical weather forecast report structure.

    structure = {
        "forecast_information": {
            # Unit system could be either US or SI.
            "unit_system": "",
            "city": "",
            },
        "current_conditions": {
            "condition": "",
            "temp_c": "",
            "humidity": "",
            "wind_condition": "",
            },
        "forecast_conditions": [
                # Forecast conditions are repeated for every each of one 4 days
                # ahead.
                {
                    # Low and High temperatures are either of Fahrenheit or
                    # Celsius scale depending on Unit system.
                    "low": "",
                    "high": "",
                    "day_of_week": "",
                    "condition": "",
                 },
            ],
        }
    """

    def element_to_dict(element):
        output = {}
        try:
            element = root.find(element)
        except TypeError:
            pass

        if element is None:
            raise APIError("Unable to retrieve weather forecast for %s" %
                           location)

        for el in list(element):
            # Skips unnecessary information fields.
            if el.tag in ("icon", "latitude_e6", "longitude_e6", "postal_code",
                          "current_date_time", "forecast_date", "temp_f"):
                continue
            output.update({el.tag: el.get("data") or None})
        return output

    # Parses XML.
    forecast_information = element_to_dict("weather/forecast_information")
    current_conditions = element_to_dict("weather/current_conditions")

    forecasts = []
    for element in root.findall("weather/forecast_conditions"):
        forecast = element_to_dict(element)
        forecasts.append(forecast)

    # Populates forecast data.
    data = {}

    if None not in current_conditions.values():
        data.update({"current_conditions": current_conditions})

    data.update({"forecast_information": forecast_information})

    unit_system = data.get("forecast_information").get("unit_system")
    forecasts_list = []
    for forecast in forecasts:
        # Skips corrupted forecast data.
        if None in forecast.values():
            continue

        if unit_system == "US":
            high = forecast.get("high")
            low = forecast.get("low")
            high, low = map(fahrenheit_to_celsius, (high, low))
            forecast.update({"high": high, "low": low})

        forecasts_list.append(forecast)

    if forecasts_list:
        data.update({"forecasts": forecasts_list})

    _cache.update({location: (time.time(), data)})
    return data


class WeatherForecast(ChatCommandPlugin):
    """Google Weather API conference chat informer plugin."""
    def __init__(self, parent):
        super(WeatherForecast, self).__init__(parent)
        self._commands = {
            "!weather": self.on_weather_command,
            }

    def on_weather_command(self, message):
        """Retrieves Google Weather API forecast information. Type
        !weather <location> to specify location which is otherwise taken from
        your Skype public profile."""

        substitutes = {
            u"дс": u"Moscow",
            u"dc": u"Moscow",
            u"default city": u"Moscow",
            u"дс2": u"Sankt-Peterburg",
            u"дс 2": u"Sankt-Peterburg",
            u"dc2": u"Sankt-Peterburg",
            u"dc 2": u"Sankt-Peterburg",
            u"spb": u"Sankt-Peterburg",
            u"спб": u"Sankt-Peterburg",
            }

        chat = message.Chat

        match = re.match(r"!weather\s+(.*)", message.Body, re.UNICODE)
        if not match:
            # Acquires location from user's Skype public profile.
            location = message.Sender.City
        else:
            location = match.group(1)

        if not location:
            line = (u"%s, city of your location has not been set in your "
                    "Skype profile. Specify the location with !weather "
                    "<location> command.") % message.FromDisplayName
            chat.SendMessage(line)
            return

        # Searches substitutes dictionary for known locations.
        # TODO: probably move this dictionary to external configuration file
        # along with other plugin settings.
        loc = location.lower().strip()
        if loc in substitutes:
            location = substitutes.get(loc)

        language = message.Sender.CountryCode or "en"

        try:
            forecast = get_google_weather_forecast(location, language)
        except APIError, e:
            chat.SendMessage(e)
            return

        # Populates output.
        output = []

        forecast_information = forecast.get("forecast_information")
        output.append(u"Weather forecast for %(city)s" % forecast_information)

        current_conditions = forecast.get("current_conditions")
        if current_conditions:
            line = (u"Current conditions: %(temp_c)s °C, %(condition)s, "
                    "%(humidity)s, %(wind_condition)s") % current_conditions
            output.append(line)

        forecasts = forecast.get("forecasts")
        if forecasts:
            output.append(u"Forecast conditions:")
            for forecast in forecasts:
                line = (u"%(day_of_week)s: %(high)s | %(low)s °C, "
                        "%(condition)s") % forecast
                output.append(line)

        chat.SendMessage("\n".join(output))
        return


if __name__ == "__main__":
    import doctest
    doctest.testmod()
