#!/usr/bin/env python
# -*- coding: utf-8 -*-


"""
@author: tetra5 <tetra5dotorg@gmail.com>
"""


__version__ = "2012.1"


import re
import urllib
import urllib2
import time

try:
    from lxml import etree
except ImportError:
    try:
        from xml.etree import cElementTree as etree
    except ImportError:
        from xml.etree import ElementTree as etree

from plugin import ChatCommandPlugin


_cache = {}
# Cache time to live in seconds.
_cache_ttl = 1200


class APIError(Exception):
    pass


def retry(exception, tries=10, delay=3, backoff=1):
    """Retries a function or method until it stops generating specified
    exception.

    @param exception: Exception generated by decorated function or method.
    @param tries: Number of tries.
    @param delay: Delay between tries in seconds.
    @param backoff: Factor by which the delay should lengthen after each
    failure.
    """
    def wrapper(f):
        def f_retry(*args, **kwargs):
            mtries, mdelay = tries, delay
            while mtries > 1:
                try:
                    return f(*args, **kwargs)
                except exception:
                    time.sleep(mdelay)
                    mtries -= 1
                    mdelay *= backoff
            return
        return f_retry
    return wrapper


def sanitize_temperature(temp):
    """
    >>> sanitize_temperature("10")
    '+10'
    >>> sanitize_temperature("-10")
    '-10'
    """
    try:
        temp = int(temp)
    except ValueError:
        return "unknown"
    return "+%s" % temp if temp > 0 else str(temp)


def fahrenheit_to_celsius(temp_f):
    """Fahrenheit to Celsius degrees conversion.

    @param temp_f: Temperature in Fahrenheit degrees.

    >>> fahrenheit_to_celsius("98.6")
    37
    >>> fahrenheit_to_celsius(98.6)
    37
    """
    if not isinstance(temp_f, float):
        temp_f = float(temp_f)
    return int((temp_f - 32) * 5 / 9)


def celsius_to_fahrenheit(temp_c):
    """Celsius to Fahrenheit degrees conversion.

    @param temp_c: Temperature in Celsius degrees.

    >>> celsius_to_fahrenheit("37")
    98
    >>> celsius_to_fahrenheit(37)
    98
    """
    if not isinstance(temp_c, float):
        temp_c = float(temp_c)
    return int(temp_c * 9 / 5 + 32)


def get_google_weather_forecast(location, language="en"):
    """Google Weather API client.

    @param location: ZIP code, city, city + country, latitude/longitude,
    whatever Google can handle.
    @param language: ISO 639-1 Language code.
    http://en.wikipedia.org/wiki/List_of_ISO_639-1_codes

    Returns parsed data dictionary.

    Raises APIError exception when:
    a) it was impossible to retrieve API response;
    b) API has returned empty response (unknown location).

    >>> data = get_google_weather_forecast(location="moscow", language="en")
    >>> city = data["forecast_information"]["city"]
    >>> city in ("Moscow, Moscow", "Moscow, Moskva")
    True
    >>> len(data["forecasts"])
    4
    """
    global _cache
    global _chache_ttl

    cached = _cache.get(location)
    if cached:
        if time.time() - cached[0] <= _cache_ttl:
            return cached[1]

    api_url = "http://www.google.com/ig/api?"

    location = location.encode("utf-8")
    url = api_url + urllib.urlencode({"weather": location, "hl": language})

    # Retrieves XML response.
    headers = {
        # Completely unnecessary.
        "User-Agent": "Googlebot/2.1 (+http://www.googlebot.com/bot.html)",
        }
    opener = urllib2.build_opener()
    opener.addheaders = [(k, v) for k, v in headers.iteritems()]

    @retry((urllib2.URLError, urllib2.HTTPError, etree.XMLSyntaxError))
    def get_and_process_response():
        response = opener.open(fullurl=url, timeout=2)
        element_tree = etree.ElementTree()
        return element_tree.parse(response)

    root = get_and_process_response()
    if root is None:
        raise APIError("Unable to retrieve Google Weather API response.")

    def element_to_dict(element):
        output = {}
        try:
            element = root.find(element)
        except TypeError:
            pass

        if element is None:
            raise APIError("Unable to retrieve weather forecast for '%s'" %
                           location)

        for el in list(element):

            # Skips unnescessary information fields.
            if el.tag in ("icon", "latitude_e6", "longitude_e6", "postal_code",
                          "current_date_time", "forecast_date"):
                continue

            el_data = el.get("data")
            if el_data is "":
                el_data = "unknown"

            output.update({el.tag: el_data})
        return output

    forecast_information = element_to_dict("weather/forecast_information")

    current_conditions = element_to_dict("weather/current_conditions")

    forecasts = list()

    for element in root.findall("weather/forecast_conditions"):
        forecast = element_to_dict(element)
        forecasts.append(forecast)

    data = {
        "forecast_information": forecast_information,
        "current_conditions": current_conditions,
        "forecasts": forecasts,
        }

    data["current_conditions"]["temp_c"] = \
        sanitize_temperature(data["current_conditions"]["temp_c"])

    # Checks if Fahrenheit to Celsius conversion is necessary (unit system is
    # set to US).
    is_si = True
    if data["forecast_information"]["unit_system"] == "US":
        is_si = False

    for forecast in data["forecasts"]:
        if not is_si:
            forecast["high"] = fahrenheit_to_celsius(forecast["high"])
            forecast["low"] = fahrenheit_to_celsius(forecast["low"])

        forecast["high"] = sanitize_temperature(forecast["high"])
        forecast["low"] = sanitize_temperature(forecast["low"])

    _cache.update({location: (time.time(), data)})
    return data


class WeatherForecast(ChatCommandPlugin):
    """Google Weather API conference chat informer plugin."""
    def __init__(self, parent):
        super(WeatherForecast, self).__init__(parent)
        self._commands = {
            "!weather": self.on_weather_command,
            }

    def on_weather_command(self, message):
        """Retrieves Google Weather API forecast information. Type
        !weather <location> to specify location which is otherwise taken from
        your Skype public profile."""

        substitutes = {
            u"дс": u"Moscow",
            u"dc": u"Moscow",
            u"default city": u"Moscow",
            u"дс2": u"Sankt-Peterburg",
            u"дс 2": u"Sankt-Peterburg",
            u"dc2": u"Sankt-Peterburg",
            u"dc 2": u"Sankt-Peterburg",
            u"spb": u"Sankt-Peterburg",
            u"спб": u"Sankt-Peterburg",
            }

        chat = message.Chat

        match = re.match(r"!weather\s+(.*)", message.Body, re.UNICODE)

        if not match:
            # Acquires location from user's Skype public profile.
            location = message.Sender.City
        else:
            location = match.group(1)

        if not location:
            chat.SendMessage(
                "%s, city of your location has not been set in your " \
                "Skype profile. Specify the location with !weather " \
                "<location> command." % message.FromDisplayName)
            return

        for k, v in substitutes.iteritems():
            if k.lower() == location.lower().strip():
                location = v
                break

        language = message.Sender.CountryCode or "en"

        try:
            forecast = get_google_weather_forecast(location, language)
        except APIError, e:
            chat.SendMessage(e)
            return

        # TODO: refactor this mess.
        output = [
            u"Weather forecast for '%s'" %
                forecast["forecast_information"]["city"],

            u"Current conditions: %s °C, %s, %s, %s" % (
                forecast["current_conditions"].get("temp_c"),
                forecast["current_conditions"].get("condition"),
                forecast["current_conditions"].get("humidity"),
                forecast["current_conditions"].get("wind_condition")),

            u"Forecast conditions:",
            ]

        forecasts = []
        for f in forecast["forecasts"]:
            day = u"%s: %s °C / %s °C, %s" % (
                f["day_of_week"], f["high"], f["low"], f["condition"])
            forecasts.append(day)

        output.append(" | ".join(forecasts))

        chat.SendMessage("\n".join(output))


if __name__ == "__main__":
    import doctest
    doctest.testmod()
